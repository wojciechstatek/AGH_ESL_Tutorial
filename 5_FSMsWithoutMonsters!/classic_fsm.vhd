-- File: classic_fsm.vhd
-- Generated by MyHDL 0.11
-- Date: Sat Nov 14 17:59:26 2020


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

entity classic_fsm is
    port (
        clk_i: in std_logic;
        inputs_i: in unsigned(1 downto 0);
        outputs_o: out unsigned(3 downto 0)
    );
end entity classic_fsm;


architecture MyHDL of classic_fsm is


type t_enum_fsm_state_s_1 is (
	A,
	B,
	C,
	D
	);

signal dbnc_inputs: unsigned(1 downto 0);
signal fsm_state: t_enum_fsm_state_s_1;
signal input_chgs: unsigned(1 downto 0);
signal prev_inputs: unsigned(1 downto 0);
signal reset_cnt: unsigned(1 downto 0);
signal chunk_insts_3_prev_button: std_logic;
signal chunk_insts_3_button_o: std_logic;
signal chunk_insts_3_debounce_cnt: unsigned(16 downto 0);
signal chunk_insts_2_prev_button: std_logic;
signal chunk_insts_2_button_o: std_logic;
signal chunk_insts_2_debounce_cnt: unsigned(16 downto 0);
signal chunk_insts_2_chunk_insts_1_a: unsigned(1 downto 0);

begin



chunk_insts_2_chunk_insts_1_a(1) <= chunk_insts_3_button_o;
chunk_insts_2_chunk_insts_1_a(0) <= chunk_insts_2_button_o;

CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_0_C: process (fsm_state) is
begin
    case fsm_state is
        when A =>
            outputs_o <= to_unsigned(1, 4);
        when B =>
            outputs_o <= to_unsigned(2, 4);
        when C =>
            outputs_o <= to_unsigned(4, 4);
        when D =>
            outputs_o <= to_unsigned(8, 4);
        when others =>
            outputs_o <= to_unsigned(15, 4);
    end case;
end process CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_0_C;


dbnc_inputs <= chunk_insts_2_chunk_insts_1_a;

CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_2_LOC_INSTS_CHUNK_INSTS_0: process (clk_i) is
begin
    if rising_edge(clk_i) then
        if (chunk_insts_2_debounce_cnt = 0) then
            chunk_insts_2_button_o <= chunk_insts_2_prev_button;
        end if;
    end if;
end process CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_2_LOC_INSTS_CHUNK_INSTS_0;

CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_2_LOC_INSTS_CHUNK_INSTS_K: process (clk_i) is
begin
    if rising_edge(clk_i) then
        if (inputs_i(0) = chunk_insts_2_prev_button) then
            if (chunk_insts_2_debounce_cnt /= 0) then
                chunk_insts_2_debounce_cnt <= (chunk_insts_2_debounce_cnt - 1);
            end if;
        else
            chunk_insts_2_debounce_cnt <= to_unsigned(120000, 17);
        end if;
        chunk_insts_2_prev_button <= inputs_i(0);
    end if;
end process CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_2_LOC_INSTS_CHUNK_INSTS_K;

CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_3_LOC_INSTS_CHUNK_INSTS_0: process (clk_i) is
begin
    if rising_edge(clk_i) then
        if (chunk_insts_3_debounce_cnt = 0) then
            chunk_insts_3_button_o <= chunk_insts_3_prev_button;
        end if;
    end if;
end process CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_3_LOC_INSTS_CHUNK_INSTS_0;

CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_3_LOC_INSTS_CHUNK_INSTS_K: process (clk_i) is
begin
    if rising_edge(clk_i) then
        if (inputs_i(1) = chunk_insts_3_prev_button) then
            if (chunk_insts_3_debounce_cnt /= 0) then
                chunk_insts_3_debounce_cnt <= (chunk_insts_3_debounce_cnt - 1);
            end if;
        else
            chunk_insts_3_debounce_cnt <= to_unsigned(120000, 17);
        end if;
        chunk_insts_3_prev_button <= inputs_i(1);
    end if;
end process CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_3_LOC_INSTS_CHUNK_INSTS_K;


input_chgs <= (dbnc_inputs and (not prev_inputs));

CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_K: process (clk_i) is
begin
    if rising_edge(clk_i) then
        if (signed(resize(reset_cnt, 3)) < (4 - 1)) then
            fsm_state <= A;
            reset_cnt <= (reset_cnt + 1);
        elsif (fsm_state = A) then
            if bool(input_chgs(0)) then
                fsm_state <= B;
            elsif bool(input_chgs(1)) then
                fsm_state <= D;
            end if;
        elsif (fsm_state = B) then
            if bool(input_chgs(0)) then
                fsm_state <= C;
            elsif bool(input_chgs(1)) then
                fsm_state <= A;
            end if;
        elsif (fsm_state = C) then
            if bool(input_chgs(0)) then
                fsm_state <= D;
            elsif bool(input_chgs(1)) then
                fsm_state <= B;
            end if;
        elsif (fsm_state = D) then
            if bool(input_chgs(0)) then
                fsm_state <= A;
            elsif bool(input_chgs(1)) then
                fsm_state <= C;
            end if;
        else
            fsm_state <= A;
        end if;
        prev_inputs <= dbnc_inputs;
    end if;
end process CLASSIC_FSM_LOC_INSTS_CHUNK_INSTS_K;

end architecture MyHDL;
